<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>Gtk4 tutorial for beginners</title>
  <style>
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    span.underline{text-decoration: underline;}
    div.column{display: inline-block; vertical-align: top; width: 50%;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
    pre > code.sourceCode { white-space: pre; position: relative; }
    pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
    pre > code.sourceCode > span:empty { height: 1.2em; }
    code.sourceCode > span { color: inherit; text-decoration: inherit; }
    div.sourceCode { margin: 1em 0; }
    pre.sourceCode { margin: 0; }
    @media screen {
    div.sourceCode { overflow: auto; }
    }
    @media print {
    pre > code.sourceCode { white-space: pre-wrap; }
    pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
    }
    pre.numberSource code
      { counter-reset: source-line 0; }
    pre.numberSource code > span
      { position: relative; left: -4em; counter-increment: source-line; }
    pre.numberSource code > span > a:first-child::before
      { content: counter(source-line);
        position: relative; left: -1em; text-align: right; vertical-align: baseline;
        border: none; display: inline-block;
        -webkit-touch-callout: none; -webkit-user-select: none;
        -khtml-user-select: none; -moz-user-select: none;
        -ms-user-select: none; user-select: none;
        padding: 0 4px; width: 4em;
        color: #aaaaaa;
      }
    pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
    div.sourceCode
      {   }
    @media screen {
    pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
    }
    code span.al { color: #ff0000; font-weight: bold; } /* Alert */
    code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
    code span.at { color: #7d9029; } /* Attribute */
    code span.bn { color: #40a070; } /* BaseN */
    code span.bu { } /* BuiltIn */
    code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
    code span.ch { color: #4070a0; } /* Char */
    code span.cn { color: #880000; } /* Constant */
    code span.co { color: #60a0b0; font-style: italic; } /* Comment */
    code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
    code span.do { color: #ba2121; font-style: italic; } /* Documentation */
    code span.dt { color: #902000; } /* DataType */
    code span.dv { color: #40a070; } /* DecVal */
    code span.er { color: #ff0000; font-weight: bold; } /* Error */
    code span.ex { } /* Extension */
    code span.fl { color: #40a070; } /* Float */
    code span.fu { color: #06287e; } /* Function */
    code span.im { } /* Import */
    code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
    code span.kw { color: #007020; font-weight: bold; } /* Keyword */
    code span.op { color: #666666; } /* Operator */
    code span.ot { color: #007020; } /* Other */
    code span.pp { color: #bc7a00; } /* Preprocessor */
    code span.sc { color: #4070a0; } /* SpecialChar */
    code span.ss { color: #bb6688; } /* SpecialString */
    code span.st { color: #4070a0; } /* String */
    code span.va { color: #19177c; } /* Variable */
    code span.vs { color: #4070a0; } /* VerbatimString */
    code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
    body {width: 1080px; margin: 0 auto; font-size: large;}
    h2 {padding: 10px; background-color: #d0f0d0; }
    div.sourceCode { margin: 10px; padding: 16px 10px 8px 10px; border: 2px solid silver; background-color: ghostwhite; overflow-x:scroll}
    pre:not(.sourceCode) { margin: 10px; padding: 16px 10px 8px 10px; border: 2px solid silver; background-color: ghostwhite; overflow-x:scroll}
    table {margin-left: auto; margin-right: auto; border-collapse: collapse; border: 1px solid;}
    th {padding: 2px 6px; border: 1px solid; background-color: ghostwhite;}
    td {padding: 2px 6px; border: 1px solid;}
    img {display: block; margin-left: auto; margin-right: auto;}
    figcaption {text-align: center;}
  </style>
</head>
<body>
<p>Up: <a href="index.html">index.html</a>, Prev: <a href="sec2.html">Section 2</a>, Next: <a href="sec4.html">Section 4</a></p>
<h1 id="type-system-and-registration-process">Type system and registration process</h1>
<p>GObject is a base object. We don’t use gobject itself usually. Because GObject is very simple and not enough to be used by itself in most situations. Instead, we use descendant objects of GObject such as many kinds of GtkWidget. We can rather say such derivability is the most important feature of GObject.</p>
<p>This section describes how to define a child object of GObject.</p>
<h2 id="name-convention">Name convention</h2>
<p>An example of this section is an object represents a real number. It is not so useful because we have already had double type in C language to represent real numbers. However, I think this example is not so bad for knowing the technique to define a child object.</p>
<p>First, you need to know the naming convention. An object name consists of name space and name. For example, “GObject” consists of a name space “G” and a name “Object”. “GtkWidget” consists of a name space “Gtk” and a name “Widget”. Let the name space be “T” and the name be “Double” of the new object. In this tutorial, we use “T” as a name space for all the objects we make.</p>
<p>TDouble is the object name. It is a child object of GObject. It represents a real number and the type of the number is double. It has some useful functions.</p>
<h2 id="define-tdoubleclass-and-tdouble">Define TDoubleClass and TDouble</h2>
<p>TDouble type object has class and instance. The type of the class is TDoubleClass. Its structure is like this:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true"></a><span class="kw">typedef</span> <span class="kw">struct</span> _TDoubleClass TDoubleClass</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true"></a><span class="kw">struct</span> _TDoubleClass {</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true"></a>  GObjectClass parent_class;</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true"></a>}</span></code></pre></div>
<p>_TDoubleClass is a C structure tag name and TDoubleClass is "struct _TDoubleClass".</p>
<ul>
<li>Use typedef to define a class type.</li>
<li>The first member of the structure must be the parent’s class structure.</li>
</ul>
<p>TDoubleClass doesn’t need its own member.</p>
<p>The type of the instance of TDouble is TDouble.</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true"></a><span class="kw">typedef</span> <span class="kw">struct</span> _TDouble TDouble</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true"></a><span class="kw">struct</span> _TDouble {</span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true"></a>  GObject parent;</span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true"></a>  <span class="dt">double</span> value;</span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true"></a>}</span></code></pre></div>
<p>This is similar to the structure of the class.</p>
<ul>
<li>Use typedef to define an instance type.</li>
<li>The first member of the structure must be the parent’s instance structure.</li>
</ul>
<p>TDouble has its own member, “value”. It is the value of TDouble instance.</p>
<p>The coding convention above needs to be kept by writers.</p>
<h2 id="creation-process-of-a-child-of-gobject">Creation process of a child of GObject</h2>
<p>The creation process of TDouble type is similar to the one of GObject.</p>
<ol type="1">
<li>Register TDouble type with type system.</li>
<li>Let the type system allocate memory for TDoubleClass and TDouble.</li>
<li>Initialize TDoubleClass.</li>
<li>Initialize TDouble.</li>
</ol>
<h2 id="registration">Registration</h2>
<p>Usually registration is done by convenient macro such as <code>G_DECLARE_FINAL_TYPE</code> and <code>G_DEFINE_TYPE</code>. So you don’t need to care about registration. But, in this tutorial, it is important to understand GObject type system, so I want to show you the registration without macro, first.</p>
<p>There are two kinds of types, static and dynamic. Static type doesn’t destroy its class even all the instances have been destroyed. Dynamic type destroys its class when the last instance has been destroyed. The type of GObject is static and its descendant objects’ type is also static. The function <code>g_type_register_static</code> registers a type of a static object. The following code is extracted from <code>gtype.h</code> in the Glib source files.</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true"></a>GType</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true"></a>g_type_register_static (GType           parent_type,</span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true"></a>                        <span class="dt">const</span> gchar     *type_name,</span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true"></a>                        <span class="dt">const</span> GTypeInfo *info,</span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true"></a>                        GTypeFlags      flags);</span></code></pre></div>
<p>The parameters above are:</p>
<ul>
<li>parent_type: Parent type.</li>
<li>type_name: The name of the type. For example, “TDouble”.</li>
<li>info: Information of the type. <code>GTypeInfo</code> structure will be explained below.</li>
<li>flags: Flag. If the type is abstract type or abstract value type, then set their flag. Otherwise, set it to zero.</li>
</ul>
<p>Because the type system maintains the parent-child relationship of the type, <code>g_type_refister_static</code> has a parent type parameter. And the type system also keeps the information of the type. After the registration, <code>g_type_register_static</code> returns the type of the new object.</p>
<p><code>GTypeInfo</code> structure is defined as follows.</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true"></a><span class="kw">typedef</span> <span class="kw">struct</span> _GTypeInfo  GTypeInfo;</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true"></a></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true"></a><span class="kw">struct</span> _GTypeInfo</span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true"></a>{</span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true"></a>  <span class="co">/* interface types, classed types, instantiated types */</span></span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true"></a>  guint16                class_size;</span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true"></a></span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true"></a>  GBaseInitFunc          base_init;</span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true"></a>  GBaseFinalizeFunc      base_finalize;</span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true"></a></span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true"></a>  <span class="co">/* interface types, classed types, instantiated types */</span></span>
<span id="cb4-12"><a href="#cb4-12" aria-hidden="true"></a>  GClassInitFunc         class_init;</span>
<span id="cb4-13"><a href="#cb4-13" aria-hidden="true"></a>  GClassFinalizeFunc     class_finalize;</span>
<span id="cb4-14"><a href="#cb4-14" aria-hidden="true"></a>  gconstpointer          class_data;</span>
<span id="cb4-15"><a href="#cb4-15" aria-hidden="true"></a></span>
<span id="cb4-16"><a href="#cb4-16" aria-hidden="true"></a>  <span class="co">/* instantiated types */</span></span>
<span id="cb4-17"><a href="#cb4-17" aria-hidden="true"></a>  guint16                instance_size;</span>
<span id="cb4-18"><a href="#cb4-18" aria-hidden="true"></a>  guint16                n_preallocs;</span>
<span id="cb4-19"><a href="#cb4-19" aria-hidden="true"></a>  GInstanceInitFunc      instance_init;</span>
<span id="cb4-20"><a href="#cb4-20" aria-hidden="true"></a></span>
<span id="cb4-21"><a href="#cb4-21" aria-hidden="true"></a>  <span class="co">/* value handling */</span></span>
<span id="cb4-22"><a href="#cb4-22" aria-hidden="true"></a>  <span class="dt">const</span> GTypeValueTable  *value_table;</span>
<span id="cb4-23"><a href="#cb4-23" aria-hidden="true"></a>};</span></code></pre></div>
<p>This structure needs to be created before the registration.</p>
<ul>
<li>class_size: The size of the class. For example, TDouble’s class size is <code>sizeof (TDoubleClass)</code>.</li>
<li>base_init, base_finalize: These function initialize/finalize the dynamic members of the class. In many cases, they aren’t necessary, and are assigned NULL. For further information, see <a href="https://docs.gtk.org/gobject/callback.BaseInitFunc.html">GObject API Reference, BaseInitFunc</a> and <a href="https://docs.gtk.org/gobject/callback.ClassInitFunc.html">GObject API Reference, ClassInitFunc</a>.</li>
<li>class_init: Initializes static members of the class. Assign your class initialization function to <code>class_init</code>member. By convention, the name is <code>&lt;name space&gt;_&lt;name&gt;_class_init</code>, for example, <code>t_double_class_init</code>.</li>
<li>class_finalize: Finalizes the class. Because descendant type of GObjec is static, it doesn’t have a finalize function. Assign NULL to <code>class_finalize</code> member.</li>
<li>class_data: User-supplied data passed to the class init/finalize functions. Usually NULL is assigned.</li>
<li>instance_size: The size of the instance. For example, TDouble’s instance size is <code>sizeof (TDouble)</code>.</li>
<li>n_preallocs: This is ignored. it has been used by the old version of Glib.</li>
<li>instance_init: Initializes instance members. Assign your instance initialization function to <code>instance_init</code> member. By convention, the name is <code>&lt;name space&gt;_&lt;name&gt;_init</code>, for example, <code>t_double_init</code>.</li>
<li>value_table: This is usually only useful for fundamental types. If the type is descendant of GObject, assign NULL.</li>
</ul>
<p>These information is kept by the type system and used when the object is created or destroyed. Class_size and instance_size are used to allocate memory for the class and instance. Class_init and instance_init functions are called when class or instance is initialized.</p>
<p><code>example3.c</code> shows how to use <code>g_type_register_static</code>.</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode numberSource C numberLines"><code class="sourceCode c"><span id="cb5-1"><a href="#cb5-1"></a><span class="pp">#include </span><span class="im">&lt;glib-object.h&gt;</span></span>
<span id="cb5-2"><a href="#cb5-2"></a></span>
<span id="cb5-3"><a href="#cb5-3"></a><span class="pp">#define T_TYPE_DOUBLE  (t_double_get_type ())</span></span>
<span id="cb5-4"><a href="#cb5-4"></a></span>
<span id="cb5-5"><a href="#cb5-5"></a><span class="kw">typedef</span> <span class="kw">struct</span> _TDouble TDouble;</span>
<span id="cb5-6"><a href="#cb5-6"></a><span class="kw">struct</span> _TDouble {</span>
<span id="cb5-7"><a href="#cb5-7"></a>  GObject parent;</span>
<span id="cb5-8"><a href="#cb5-8"></a>  <span class="dt">double</span> value;</span>
<span id="cb5-9"><a href="#cb5-9"></a>};</span>
<span id="cb5-10"><a href="#cb5-10"></a></span>
<span id="cb5-11"><a href="#cb5-11"></a><span class="kw">typedef</span> <span class="kw">struct</span> _TDoubleClass TDoubleClass;</span>
<span id="cb5-12"><a href="#cb5-12"></a><span class="kw">struct</span> _TDoubleClass {</span>
<span id="cb5-13"><a href="#cb5-13"></a>  GObjectClass parent_class;</span>
<span id="cb5-14"><a href="#cb5-14"></a>};</span>
<span id="cb5-15"><a href="#cb5-15"></a></span>
<span id="cb5-16"><a href="#cb5-16"></a><span class="dt">static</span> <span class="dt">void</span></span>
<span id="cb5-17"><a href="#cb5-17"></a>t_double_class_init (TDoubleClass *class) {</span>
<span id="cb5-18"><a href="#cb5-18"></a>}</span>
<span id="cb5-19"><a href="#cb5-19"></a></span>
<span id="cb5-20"><a href="#cb5-20"></a><span class="dt">static</span> <span class="dt">void</span></span>
<span id="cb5-21"><a href="#cb5-21"></a>t_double_init (TDouble *d) {</span>
<span id="cb5-22"><a href="#cb5-22"></a>}</span>
<span id="cb5-23"><a href="#cb5-23"></a></span>
<span id="cb5-24"><a href="#cb5-24"></a>GType</span>
<span id="cb5-25"><a href="#cb5-25"></a>t_double_get_type (<span class="dt">void</span>) {</span>
<span id="cb5-26"><a href="#cb5-26"></a>  <span class="dt">static</span> GType type = <span class="dv">0</span>;</span>
<span id="cb5-27"><a href="#cb5-27"></a>  GTypeInfo info;</span>
<span id="cb5-28"><a href="#cb5-28"></a></span>
<span id="cb5-29"><a href="#cb5-29"></a>  <span class="cf">if</span> (type == <span class="dv">0</span>) {</span>
<span id="cb5-30"><a href="#cb5-30"></a>    info.class_size = <span class="kw">sizeof</span> (TDoubleClass);</span>
<span id="cb5-31"><a href="#cb5-31"></a>    info.base_init = NULL;</span>
<span id="cb5-32"><a href="#cb5-32"></a>    info.base_finalize = NULL;</span>
<span id="cb5-33"><a href="#cb5-33"></a>    info.class_init = (GClassInitFunc)  t_double_class_init;</span>
<span id="cb5-34"><a href="#cb5-34"></a>    info.class_finalize = NULL;</span>
<span id="cb5-35"><a href="#cb5-35"></a>    info.class_data = NULL;</span>
<span id="cb5-36"><a href="#cb5-36"></a>    info.instance_size = <span class="kw">sizeof</span> (TDouble);</span>
<span id="cb5-37"><a href="#cb5-37"></a>    info.n_preallocs = <span class="dv">0</span>;</span>
<span id="cb5-38"><a href="#cb5-38"></a>    info.instance_init = (GInstanceInitFunc)  t_double_init;</span>
<span id="cb5-39"><a href="#cb5-39"></a>    info.value_table = NULL;</span>
<span id="cb5-40"><a href="#cb5-40"></a>    type = g_type_register_static (G_TYPE_OBJECT, <span class="st">&quot;TDouble&quot;</span>, &amp;info, <span class="dv">0</span>);</span>
<span id="cb5-41"><a href="#cb5-41"></a>  }</span>
<span id="cb5-42"><a href="#cb5-42"></a>  <span class="cf">return</span> type;</span>
<span id="cb5-43"><a href="#cb5-43"></a>}</span>
<span id="cb5-44"><a href="#cb5-44"></a></span>
<span id="cb5-45"><a href="#cb5-45"></a><span class="dt">int</span></span>
<span id="cb5-46"><a href="#cb5-46"></a>main (<span class="dt">int</span> argc, <span class="dt">char</span> **argv) {</span>
<span id="cb5-47"><a href="#cb5-47"></a>  GType dtype;</span>
<span id="cb5-48"><a href="#cb5-48"></a>  TDouble *d;</span>
<span id="cb5-49"><a href="#cb5-49"></a></span>
<span id="cb5-50"><a href="#cb5-50"></a>  dtype = t_double_get_type (); <span class="co">/* or d = T_TYPE_DOUBLE */</span></span>
<span id="cb5-51"><a href="#cb5-51"></a>  <span class="cf">if</span> (dtype)</span>
<span id="cb5-52"><a href="#cb5-52"></a>    g_print (<span class="st">&quot;Registration was a success. The type is %lx.</span><span class="sc">\n</span><span class="st">&quot;</span>, dtype);</span>
<span id="cb5-53"><a href="#cb5-53"></a>  <span class="cf">else</span></span>
<span id="cb5-54"><a href="#cb5-54"></a>    g_print (<span class="st">&quot;Registration failed.</span><span class="sc">\n</span><span class="st">&quot;</span>);</span>
<span id="cb5-55"><a href="#cb5-55"></a></span>
<span id="cb5-56"><a href="#cb5-56"></a>  d = g_object_new (T_TYPE_DOUBLE, NULL);</span>
<span id="cb5-57"><a href="#cb5-57"></a>  <span class="cf">if</span> (d)</span>
<span id="cb5-58"><a href="#cb5-58"></a>    g_print (<span class="st">&quot;Instantiation was a success. The instance address is %p.</span><span class="sc">\n</span><span class="st">&quot;</span>, d);</span>
<span id="cb5-59"><a href="#cb5-59"></a>  <span class="cf">else</span></span>
<span id="cb5-60"><a href="#cb5-60"></a>    g_print (<span class="st">&quot;Instantiation failed.</span><span class="sc">\n</span><span class="st">&quot;</span>);</span>
<span id="cb5-61"><a href="#cb5-61"></a></span>
<span id="cb5-62"><a href="#cb5-62"></a>  <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb5-63"><a href="#cb5-63"></a>}</span></code></pre></div>
<ul>
<li>16-22: A class initialization function and an instance initialization function. They do nothing here but they are necessary for the registration.</li>
<li>24-43: <code>t_double_get_type</code> function. This function returns the type of the TDouble object. The name of a function is always <code>&lt;name space&gt;_&lt;name&gt;_get_type</code>. And a macro <code>&lt;NAME_SPACE&gt;_TYPE_&lt;NAME&gt;</code> (all characters are upper case) is replaced by this function. Look at line 3. <code>T_TYPE_DOUBLE</code> is a macro replaced by <code>t_double_get_type ()</code>. This function has a static variable <code>type</code> to keep the type of the object. At the first call of this function, <code>type</code> is zero. Then it calls <code>g_type_register_static</code> to register the object to the type system. At the second or subsequent call, the function just return <code>type</code>, because the static variable <code>type</code> has been assigned non-zero value by <code>g_type_register_static</code> and it keeps the value.</li>
<li>30-40 : Sets <code>info</code> structure and calls <code>g_type_register_static</code>.</li>
<li>45-63: Main function. Gets the type of TDouble object and displays it. <code>g_object_new</code> is used to instantiate the object. Shows the address of the instance.</li>
</ul>
<p><code>example3.c</code> is in the <a href="../src/misc">src/misc</a> directory.</p>
<p>Execute it.</p>
<pre><code>$ cd misc; _build/example3
Registration was a success. The type is 55c7af0b4430.
Instantiation was a success. The instance address is 0x55c7af0b6c00.</code></pre>
<h2 id="g_define_type-macro">G_DEFINE_TYPE macro</h2>
<p>The registration above is always done with the same algorithm. Therefore, it can be defined as a macro such as <code>G_DEFINE_TYPE</code>.</p>
<p><code>G_DEFINE_TYPE</code> does the following:</p>
<ul>
<li>Declares a class initialization function. Its name is <code>&lt;name space&gt;_&lt;name&gt;_class_init</code>. For example, if the object name is <code>TDouble</code>, it is <code>t_double_class_init</code>. This is a declaration, not a definition. You need to define it.</li>
<li>Declares a instance initialization function. Its name is <code>&lt;name space&gt;_&lt;name&gt;_init</code>. For example, if the object name is <code>TDouble</code>, it is <code>t_double_init</code>. This is a declaration, not a definition. You need to define it.</li>
<li>Defines a static variable pointing to the parent class. Its name is <code>&lt;name space&gt;_&lt;name&gt;_parent_class</code>. For example, if the object name is <code>TDouble</code>, it is <code>t_double_parent_class</code>.</li>
<li>Defines a <code>&lt;name space&gt;_&lt;name&gt;_get_type ()</code> function. For example, if the object name is <code>TDouble</code>, it is <code>t_double_get_type</code>. The registration is done in this function like the previous subsection.</li>
</ul>
<p>Using this macro reduces lines of the program. See the following sample <code>example4.c</code> which works the same as <code>example3.c</code>.</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode numberSource C numberLines"><code class="sourceCode c"><span id="cb7-1"><a href="#cb7-1"></a><span class="pp">#include </span><span class="im">&lt;glib-object.h&gt;</span></span>
<span id="cb7-2"><a href="#cb7-2"></a></span>
<span id="cb7-3"><a href="#cb7-3"></a><span class="pp">#define T_TYPE_DOUBLE  (t_double_get_type ())</span></span>
<span id="cb7-4"><a href="#cb7-4"></a></span>
<span id="cb7-5"><a href="#cb7-5"></a><span class="kw">typedef</span> <span class="kw">struct</span> _TDouble TDouble;</span>
<span id="cb7-6"><a href="#cb7-6"></a><span class="kw">struct</span> _TDouble {</span>
<span id="cb7-7"><a href="#cb7-7"></a>  GObject parent;</span>
<span id="cb7-8"><a href="#cb7-8"></a>  <span class="dt">double</span> value;</span>
<span id="cb7-9"><a href="#cb7-9"></a>};</span>
<span id="cb7-10"><a href="#cb7-10"></a></span>
<span id="cb7-11"><a href="#cb7-11"></a><span class="kw">typedef</span> <span class="kw">struct</span> _TDoubleClass TDoubleClass;</span>
<span id="cb7-12"><a href="#cb7-12"></a><span class="kw">struct</span> _TDoubleClass {</span>
<span id="cb7-13"><a href="#cb7-13"></a>  GObjectClass parent_class;</span>
<span id="cb7-14"><a href="#cb7-14"></a>};</span>
<span id="cb7-15"><a href="#cb7-15"></a></span>
<span id="cb7-16"><a href="#cb7-16"></a>G_DEFINE_TYPE (TDouble, t_double, G_TYPE_OBJECT)</span>
<span id="cb7-17"><a href="#cb7-17"></a></span>
<span id="cb7-18"><a href="#cb7-18"></a><span class="dt">static</span> <span class="dt">void</span></span>
<span id="cb7-19"><a href="#cb7-19"></a>t_double_class_init (TDoubleClass *class) {</span>
<span id="cb7-20"><a href="#cb7-20"></a>}</span>
<span id="cb7-21"><a href="#cb7-21"></a></span>
<span id="cb7-22"><a href="#cb7-22"></a><span class="dt">static</span> <span class="dt">void</span></span>
<span id="cb7-23"><a href="#cb7-23"></a>t_double_init (TDouble *d) {</span>
<span id="cb7-24"><a href="#cb7-24"></a>}</span>
<span id="cb7-25"><a href="#cb7-25"></a></span>
<span id="cb7-26"><a href="#cb7-26"></a><span class="dt">int</span></span>
<span id="cb7-27"><a href="#cb7-27"></a>main (<span class="dt">int</span> argc, <span class="dt">char</span> **argv) {</span>
<span id="cb7-28"><a href="#cb7-28"></a>  GType dtype;</span>
<span id="cb7-29"><a href="#cb7-29"></a>  TDouble *d;</span>
<span id="cb7-30"><a href="#cb7-30"></a></span>
<span id="cb7-31"><a href="#cb7-31"></a>  dtype = t_double_get_type (); <span class="co">/* or d = T_TYPE_DOUBLE */</span></span>
<span id="cb7-32"><a href="#cb7-32"></a>  <span class="cf">if</span> (dtype)</span>
<span id="cb7-33"><a href="#cb7-33"></a>    g_print (<span class="st">&quot;Registration was a success. The type is %lx.</span><span class="sc">\n</span><span class="st">&quot;</span>, dtype);</span>
<span id="cb7-34"><a href="#cb7-34"></a>  <span class="cf">else</span></span>
<span id="cb7-35"><a href="#cb7-35"></a>    g_print (<span class="st">&quot;Registration failed.</span><span class="sc">\n</span><span class="st">&quot;</span>);</span>
<span id="cb7-36"><a href="#cb7-36"></a></span>
<span id="cb7-37"><a href="#cb7-37"></a>  d = g_object_new (T_TYPE_DOUBLE, NULL);</span>
<span id="cb7-38"><a href="#cb7-38"></a>  <span class="cf">if</span> (d)</span>
<span id="cb7-39"><a href="#cb7-39"></a>    g_print (<span class="st">&quot;Instantiation was a success. The instance address is %p.</span><span class="sc">\n</span><span class="st">&quot;</span>, d);</span>
<span id="cb7-40"><a href="#cb7-40"></a>  <span class="cf">else</span></span>
<span id="cb7-41"><a href="#cb7-41"></a>    g_print (<span class="st">&quot;Instantiation failed.</span><span class="sc">\n</span><span class="st">&quot;</span>);</span>
<span id="cb7-42"><a href="#cb7-42"></a></span>
<span id="cb7-43"><a href="#cb7-43"></a>  <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb7-44"><a href="#cb7-44"></a>}</span></code></pre></div>
<p>Thanks to <code>G_DEFINE_TYPE</code>, we are freed from writing bothersome code like <code>GTypeInfo</code> and <code>g_type_register_static</code>. One important thing to be careful is to follow the convention of the naming of init functions.</p>
<p>Execute it.</p>
<pre><code>$ cd misc; _build/example4
Registration was a success. The type is 5644d1dd1430.
Instantiation was a success. The instance address is 0x5644d1dd2c00.</code></pre>
<h2 id="g_declare_final_type-macro">G_DECLARE_FINAL_TYPE macro</h2>
<p>Another useful macro is <code>G_DECLARE_FINAL_TYPE</code> macro. This macro can be used for a final type. A final type doesn’t have any children. If a type has children, it is a derivable type. If you want to define a derivable type object, use <code>G_DECLARE_DERIVABLE_TYPE</code> instead. However, you probably write final type objects in most cases.</p>
<p><code>G_DECLARE_FINAL_TYPE</code> does the following:</p>
<ul>
<li>Declares <code>&lt;name space&gt;_&lt;name&gt;_get_type ()</code> function. This is only declaration. You need to define it. But you can use <code>G_DEFINE_TYPE</code>, its expansion includes the definition of the function. So, you actually don’t need to write the definition by yourself.</li>
<li>The C type of the object is defined as a typedef of structure. For example, if the object name is <code>TDouble</code>, then <code>typedef struct _TDouble TDouble</code> is included in the expansion. But you need to define the structure <code>struct _TDouble</code> by yourself before <code>G_DEFINE_TYPE</code>.</li>
<li><code>&lt;NAME SPACE&gt;_&lt;NAME&gt;</code> macro is defined. For example, if the object is <code>TDouble</code> the macro is <code>T_DOUBLE</code>. It will be expanded to a function which casts the argument to the pointer to the object. For example, <code>T_Double (obj)</code> casts the type of <code>obj</code> to <code>TDouble *</code>.</li>
<li><code>&lt;NAME SPACE&gt;_IS_&lt;NAME&gt;</code> macro is defined. For example, if the object is <code>TDouble</code> the macro is <code>T_IS_DOUBLE</code>. It will be expanded to a function which checks if the argument points the instance of <code>TDouble</code>. It returns true if the argument points a descendant of <code>TDouble</code>.</li>
<li>The class structure is defined. A final type object doesn’t need to have its own member of class structure. The definition is like the line 11 to 14 in the <code>example4.c</code>.</li>
</ul>
<p>You need to write the macro definition of the type of the object before <code>G_DECLARE_FINAL_TYPE</code>. For example, if the object is <code>TDouble</code>, then</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true"></a><span class="pp">#define T_TYPE_DOUBLE  (t_double_get_type ())</span></span></code></pre></div>
<p>needs to be defined before <code>G_DECLARE_FINAL_TYPE</code>.</p>
<p><code>example5.c</code> uses this macro. It works like <code>example3.c</code> or <code>example4.c</code>.</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode numberSource C numberLines"><code class="sourceCode c"><span id="cb10-1"><a href="#cb10-1"></a><span class="pp">#include </span><span class="im">&lt;glib-object.h&gt;</span></span>
<span id="cb10-2"><a href="#cb10-2"></a></span>
<span id="cb10-3"><a href="#cb10-3"></a><span class="pp">#define T_TYPE_DOUBLE  (t_double_get_type ())</span></span>
<span id="cb10-4"><a href="#cb10-4"></a>G_DECLARE_FINAL_TYPE (TDouble, t_double, T, DOUBLE, GObject)</span>
<span id="cb10-5"><a href="#cb10-5"></a></span>
<span id="cb10-6"><a href="#cb10-6"></a><span class="kw">struct</span> _TDouble {</span>
<span id="cb10-7"><a href="#cb10-7"></a>  GObject parent;</span>
<span id="cb10-8"><a href="#cb10-8"></a>  <span class="dt">double</span> value;</span>
<span id="cb10-9"><a href="#cb10-9"></a>};</span>
<span id="cb10-10"><a href="#cb10-10"></a></span>
<span id="cb10-11"><a href="#cb10-11"></a>G_DEFINE_TYPE (TDouble, t_double, G_TYPE_OBJECT)</span>
<span id="cb10-12"><a href="#cb10-12"></a></span>
<span id="cb10-13"><a href="#cb10-13"></a><span class="dt">static</span> <span class="dt">void</span></span>
<span id="cb10-14"><a href="#cb10-14"></a>t_double_class_init (TDoubleClass *class) {</span>
<span id="cb10-15"><a href="#cb10-15"></a>}</span>
<span id="cb10-16"><a href="#cb10-16"></a></span>
<span id="cb10-17"><a href="#cb10-17"></a><span class="dt">static</span> <span class="dt">void</span></span>
<span id="cb10-18"><a href="#cb10-18"></a>t_double_init (TDouble *d) {</span>
<span id="cb10-19"><a href="#cb10-19"></a>}</span>
<span id="cb10-20"><a href="#cb10-20"></a></span>
<span id="cb10-21"><a href="#cb10-21"></a><span class="dt">int</span></span>
<span id="cb10-22"><a href="#cb10-22"></a>main (<span class="dt">int</span> argc, <span class="dt">char</span> **argv) {</span>
<span id="cb10-23"><a href="#cb10-23"></a>  GType dtype;</span>
<span id="cb10-24"><a href="#cb10-24"></a>  TDouble *d;</span>
<span id="cb10-25"><a href="#cb10-25"></a></span>
<span id="cb10-26"><a href="#cb10-26"></a>  dtype = t_double_get_type (); <span class="co">/* or d = T_TYPE_DOUBLE */</span></span>
<span id="cb10-27"><a href="#cb10-27"></a>  <span class="cf">if</span> (dtype)</span>
<span id="cb10-28"><a href="#cb10-28"></a>    g_print (<span class="st">&quot;Registration was a success. The type is %lx.</span><span class="sc">\n</span><span class="st">&quot;</span>, dtype);</span>
<span id="cb10-29"><a href="#cb10-29"></a>  <span class="cf">else</span></span>
<span id="cb10-30"><a href="#cb10-30"></a>    g_print (<span class="st">&quot;Registration failed.</span><span class="sc">\n</span><span class="st">&quot;</span>);</span>
<span id="cb10-31"><a href="#cb10-31"></a></span>
<span id="cb10-32"><a href="#cb10-32"></a>  d = g_object_new (T_TYPE_DOUBLE, NULL);</span>
<span id="cb10-33"><a href="#cb10-33"></a>  <span class="cf">if</span> (d)</span>
<span id="cb10-34"><a href="#cb10-34"></a>    g_print (<span class="st">&quot;Instantiation was a success. The instance address is %p.</span><span class="sc">\n</span><span class="st">&quot;</span>, d);</span>
<span id="cb10-35"><a href="#cb10-35"></a>  <span class="cf">else</span></span>
<span id="cb10-36"><a href="#cb10-36"></a>    g_print (<span class="st">&quot;Instantiation failed.</span><span class="sc">\n</span><span class="st">&quot;</span>);</span>
<span id="cb10-37"><a href="#cb10-37"></a></span>
<span id="cb10-38"><a href="#cb10-38"></a>  <span class="cf">if</span> (T_IS_DOUBLE (d))</span>
<span id="cb10-39"><a href="#cb10-39"></a>    g_print (<span class="st">&quot;d is TDouble instance.</span><span class="sc">\n</span><span class="st">&quot;</span>);</span>
<span id="cb10-40"><a href="#cb10-40"></a>  <span class="cf">else</span></span>
<span id="cb10-41"><a href="#cb10-41"></a>    g_print (<span class="st">&quot;d is not TDouble instance.</span><span class="sc">\n</span><span class="st">&quot;</span>);</span>
<span id="cb10-42"><a href="#cb10-42"></a></span>
<span id="cb10-43"><a href="#cb10-43"></a>  <span class="cf">if</span> (G_IS_OBJECT (d))</span>
<span id="cb10-44"><a href="#cb10-44"></a>    g_print (<span class="st">&quot;d is GObject instance.</span><span class="sc">\n</span><span class="st">&quot;</span>);</span>
<span id="cb10-45"><a href="#cb10-45"></a>  <span class="cf">else</span></span>
<span id="cb10-46"><a href="#cb10-46"></a>    g_print (<span class="st">&quot;d is not GObject instance.</span><span class="sc">\n</span><span class="st">&quot;</span>);</span>
<span id="cb10-47"><a href="#cb10-47"></a></span>
<span id="cb10-48"><a href="#cb10-48"></a>  <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb10-49"><a href="#cb10-49"></a>}</span></code></pre></div>
<p>Execute it.</p>
<pre><code>$ cd misc; _build/example5
Registration was a success. The type is 55d0828c4430.
Instantiation was a success. The instance address is 0x55d0828c5c00.
d is TDouble instance.
d is GObject instance.</code></pre>
<h2 id="separate-the-file-into-main.c-tdouble.h-and-tdouble.c">Separate the file into main.c, tdouble.h and tdouble.c</h2>
<p>Now it’s time to separate the contents into three files, <code>main.c</code>, <code>tdouble.h</code> and <code>tdouble.c</code>. An object is defined by two files, header file and C source file.</p>
<p>tdouble.h</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode numberSource C numberLines"><code class="sourceCode c"><span id="cb12-1"><a href="#cb12-1"></a><span class="pp">#ifndef __T_DOUBLE_H__</span></span>
<span id="cb12-2"><a href="#cb12-2"></a><span class="pp">#define __T_DOUBLE_H__</span></span>
<span id="cb12-3"><a href="#cb12-3"></a></span>
<span id="cb12-4"><a href="#cb12-4"></a><span class="pp">#include </span><span class="im">&lt;glib-object.h&gt;</span></span>
<span id="cb12-5"><a href="#cb12-5"></a></span>
<span id="cb12-6"><a href="#cb12-6"></a><span class="pp">#define T_TYPE_DOUBLE  (t_double_get_type ())</span></span>
<span id="cb12-7"><a href="#cb12-7"></a>G_DECLARE_FINAL_TYPE (TDouble, t_double, T, DOUBLE, GObject)</span>
<span id="cb12-8"><a href="#cb12-8"></a></span>
<span id="cb12-9"><a href="#cb12-9"></a>gboolean</span>
<span id="cb12-10"><a href="#cb12-10"></a>t_double_get_value (TDouble *d, <span class="dt">double</span> *value);</span>
<span id="cb12-11"><a href="#cb12-11"></a></span>
<span id="cb12-12"><a href="#cb12-12"></a><span class="dt">void</span></span>
<span id="cb12-13"><a href="#cb12-13"></a>t_double_set_value (TDouble *d, <span class="dt">double</span> value);</span>
<span id="cb12-14"><a href="#cb12-14"></a></span>
<span id="cb12-15"><a href="#cb12-15"></a>TDouble *</span>
<span id="cb12-16"><a href="#cb12-16"></a>t_double_new (<span class="dt">double</span> value);</span>
<span id="cb12-17"><a href="#cb12-17"></a></span>
<span id="cb12-18"><a href="#cb12-18"></a><span class="pp">#endif </span><span class="co">/* __T_DOUBLE_H__ */</span></span></code></pre></div>
<ul>
<li>The contents of header files are public, i.e. it is open to any files. Header files include macros, which gives type information, cast and type check, and public functions.</li>
<li>1,2,18: These directives prevent that the header file is read two times or more.</li>
<li>6,7: <code>T_TYPE_DOUBLE</code> is public. <code>G_DECLARE_FINAL_TYPE</code> is also expanded to public definitions.</li>
<li>9-13: Function declarations. They are getter and setter of the value of the object.</li>
<li>15-16: Object instantiation function.</li>
</ul>
<p>tdouble.c</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode numberSource C numberLines"><code class="sourceCode c"><span id="cb13-1"><a href="#cb13-1"></a><span class="pp">#include </span><span class="im">&quot;tdouble.h&quot;</span></span>
<span id="cb13-2"><a href="#cb13-2"></a></span>
<span id="cb13-3"><a href="#cb13-3"></a><span class="kw">struct</span> _TDouble {</span>
<span id="cb13-4"><a href="#cb13-4"></a>  GObject parent;</span>
<span id="cb13-5"><a href="#cb13-5"></a>  <span class="dt">double</span> value;</span>
<span id="cb13-6"><a href="#cb13-6"></a>};</span>
<span id="cb13-7"><a href="#cb13-7"></a></span>
<span id="cb13-8"><a href="#cb13-8"></a>G_DEFINE_TYPE (TDouble, t_double, G_TYPE_OBJECT)</span>
<span id="cb13-9"><a href="#cb13-9"></a></span>
<span id="cb13-10"><a href="#cb13-10"></a><span class="dt">static</span> <span class="dt">void</span></span>
<span id="cb13-11"><a href="#cb13-11"></a>t_double_class_init (TDoubleClass *class) {</span>
<span id="cb13-12"><a href="#cb13-12"></a>}</span>
<span id="cb13-13"><a href="#cb13-13"></a></span>
<span id="cb13-14"><a href="#cb13-14"></a><span class="dt">static</span> <span class="dt">void</span></span>
<span id="cb13-15"><a href="#cb13-15"></a>t_double_init (TDouble *d) {</span>
<span id="cb13-16"><a href="#cb13-16"></a>}</span>
<span id="cb13-17"><a href="#cb13-17"></a></span>
<span id="cb13-18"><a href="#cb13-18"></a>gboolean</span>
<span id="cb13-19"><a href="#cb13-19"></a>t_double_get_value (TDouble *d, <span class="dt">double</span> *value) {</span>
<span id="cb13-20"><a href="#cb13-20"></a>  g_return_val_if_fail (T_IS_DOUBLE (d), FALSE);</span>
<span id="cb13-21"><a href="#cb13-21"></a></span>
<span id="cb13-22"><a href="#cb13-22"></a>  *value = d-&gt;value;</span>
<span id="cb13-23"><a href="#cb13-23"></a>  <span class="cf">return</span> TRUE;</span>
<span id="cb13-24"><a href="#cb13-24"></a>}</span>
<span id="cb13-25"><a href="#cb13-25"></a></span>
<span id="cb13-26"><a href="#cb13-26"></a><span class="dt">void</span></span>
<span id="cb13-27"><a href="#cb13-27"></a>t_double_set_value (TDouble *d, <span class="dt">double</span> value) {</span>
<span id="cb13-28"><a href="#cb13-28"></a>  g_return_if_fail (T_IS_DOUBLE (d));</span>
<span id="cb13-29"><a href="#cb13-29"></a></span>
<span id="cb13-30"><a href="#cb13-30"></a>  d-&gt;value = value;</span>
<span id="cb13-31"><a href="#cb13-31"></a>}</span>
<span id="cb13-32"><a href="#cb13-32"></a></span>
<span id="cb13-33"><a href="#cb13-33"></a>TDouble *</span>
<span id="cb13-34"><a href="#cb13-34"></a>t_double_new (<span class="dt">double</span> value) {</span>
<span id="cb13-35"><a href="#cb13-35"></a>  TDouble *d;</span>
<span id="cb13-36"><a href="#cb13-36"></a></span>
<span id="cb13-37"><a href="#cb13-37"></a>  d = g_object_new (T_TYPE_DOUBLE, NULL);</span>
<span id="cb13-38"><a href="#cb13-38"></a>  d-&gt;value = value;</span>
<span id="cb13-39"><a href="#cb13-39"></a>  <span class="cf">return</span> d;</span>
<span id="cb13-40"><a href="#cb13-40"></a>}</span></code></pre></div>
<ul>
<li>3-6: Declaration of the instance structure. Since <code>G_DECLARE_FINAL_TYPE</code> macro emits <code>typeder struct _TDouble TDouble</code>, the tag name of the structure must be <code>_TDouble</code>.</li>
<li>8: <code>G_DEFINE_TYPE</code> macro.</li>
<li>10-16: class and instance initialization functions. At present, they don’t do anything.</li>
<li>18-24: Getter. The argument <code>value</code> is a pointer to double type variable. Assigns the object value (<code>d-&gt;value</code>) to the variable. If it succeeds, it returns TRUE. <code>g_return_val_if_fail</code> is used to check the argument type. If the argument <code>d</code> is not TDouble type, it outputs error to the log and immediately returns FALSE. This function is used to report a programmer’s error. You shouldn’t use it for a runtime error. See <a href="https://docs.gtk.org/glib/error-reporting.html">Glib API Reference, Error Reporting</a> for further information. <code>g_return_val_if_fail</code> isn’t used in static class functions, they are private, because static functions are called only from functions in the same file. Such functions know the parameters type well. <code>g_return_val_if_fail</code> is used in public functions.</li>
<li>26-31: Setter. <code>g_return_if_fail</code> function is used to check the argument type. This function doesn’t return any value. Because the type of <code>t_double_set_value</code> is <code>void</code> so no value will be returned. Therefore, we use <code>g_return_if_fail</code> instead of <code>g_return_val_if_fail</code>.</li>
<li>33-40: Object instantiation function. It has one parameter <code>value</code> to set the value of the object.</li>
<li>37: This function uses <code>g_object_new</code> to instantiate the object. The argument <code>T_TYPE_DOUBLE</code> is expanded to a function <code>t_double_get_type ()</code>. If this is the first call for <code>t_double_get_type</code>, the type registration will be carried out.</li>
</ul>
<p>main.c</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode numberSource C numberLines"><code class="sourceCode c"><span id="cb14-1"><a href="#cb14-1"></a><span class="pp">#include </span><span class="im">&lt;glib-object.h&gt;</span></span>
<span id="cb14-2"><a href="#cb14-2"></a><span class="pp">#include </span><span class="im">&quot;tdouble.h&quot;</span></span>
<span id="cb14-3"><a href="#cb14-3"></a></span>
<span id="cb14-4"><a href="#cb14-4"></a><span class="dt">int</span></span>
<span id="cb14-5"><a href="#cb14-5"></a>main (<span class="dt">int</span> argc, <span class="dt">char</span> **argv) {</span>
<span id="cb14-6"><a href="#cb14-6"></a>  TDouble *d;</span>
<span id="cb14-7"><a href="#cb14-7"></a>  <span class="dt">double</span> value;</span>
<span id="cb14-8"><a href="#cb14-8"></a></span>
<span id="cb14-9"><a href="#cb14-9"></a>  d = t_double_new (<span class="fl">10.0</span>);</span>
<span id="cb14-10"><a href="#cb14-10"></a>  <span class="cf">if</span> (t_double_get_value (d, &amp;value))</span>
<span id="cb14-11"><a href="#cb14-11"></a>    g_print (<span class="st">&quot;t_double_get_value succesfully assigned %lf to value.</span><span class="sc">\n</span><span class="st">&quot;</span>, value);</span>
<span id="cb14-12"><a href="#cb14-12"></a>  <span class="cf">else</span></span>
<span id="cb14-13"><a href="#cb14-13"></a>    g_print (<span class="st">&quot;t_double_get_value failed.</span><span class="sc">\n</span><span class="st">&quot;</span>);</span>
<span id="cb14-14"><a href="#cb14-14"></a></span>
<span id="cb14-15"><a href="#cb14-15"></a>  t_double_set_value (d, -<span class="fl">20.0</span>);</span>
<span id="cb14-16"><a href="#cb14-16"></a>  g_print (<span class="st">&quot;Now, set d (tDouble object) with %lf.</span><span class="sc">\n</span><span class="st">&quot;</span>, -<span class="fl">20.0</span>);</span>
<span id="cb14-17"><a href="#cb14-17"></a>  <span class="cf">if</span> (t_double_get_value (d, &amp;value))</span>
<span id="cb14-18"><a href="#cb14-18"></a>    g_print (<span class="st">&quot;t_double_get_value succesfully assigned %lf to value.</span><span class="sc">\n</span><span class="st">&quot;</span>, value);</span>
<span id="cb14-19"><a href="#cb14-19"></a>  <span class="cf">else</span></span>
<span id="cb14-20"><a href="#cb14-20"></a>    g_print (<span class="st">&quot;t_double_get_value failed.</span><span class="sc">\n</span><span class="st">&quot;</span>);</span>
<span id="cb14-21"><a href="#cb14-21"></a></span>
<span id="cb14-22"><a href="#cb14-22"></a>  <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb14-23"><a href="#cb14-23"></a>}</span></code></pre></div>
<ul>
<li>2: Includes <code>tdouble.h</code>. This is necessary for accessing TDouble object.</li>
<li>9: Instantiate TDouble object and set <code>d</code> to point the object.</li>
<li>10-13: Tests the getter of the object.</li>
<li>15-20: Tests the setter of the object.</li>
</ul>
<p>The source files are located in <a href="../src/tdouble1">src/tdouble1</a>. Change your current directory to the directory above and type the following.</p>
<pre><code>meson _build
ninja -C _build</code></pre>
<p>Then, execute the program.</p>
<pre><code>$ cd tdouble1; _build/example6
t_double_get_value succesfully assigned 10.000000 to value.
Now, set d (tDouble object) with -20.000000.
t_double_get_value succesfully assigned -20.000000 to value.</code></pre>
<p>This example is very simple. But any object has header file and C source file as the example above has. And they follow the convention. You probably aware of the importance of the convention. For the further information refer to <a href="https://docs.gtk.org/gobject/concepts.html#conventions">GObject API Reference, Conventions</a>.</p>
<h2 id="functions">Functions</h2>
<p>Functions of objects are open to other objects. They are like public methods in object oriented languages.</p>
<p>It is natural to add calculation operators to TDouble objects because they represent real numbers. For example, <code>t_double_add</code> adds the value of the instance and another instance. Then it creates a new TDouble instance which value is the sum of the values.</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true"></a>TDouble *</span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true"></a>t_double_add (TDouble *self, TDouble *other) {</span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true"></a>  g_return_val_if_fail (T_IS_DOUBLE (self), NULL);</span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true"></a>  g_return_val_if_fail (T_IS_DOUBLE (other), NULL);</span>
<span id="cb17-5"><a href="#cb17-5" aria-hidden="true"></a>  <span class="dt">double</span> value;</span>
<span id="cb17-6"><a href="#cb17-6" aria-hidden="true"></a></span>
<span id="cb17-7"><a href="#cb17-7" aria-hidden="true"></a>  <span class="cf">if</span> (! t_double_get_value (other, &amp;value))</span>
<span id="cb17-8"><a href="#cb17-8" aria-hidden="true"></a>    <span class="cf">return</span> NULL;</span>
<span id="cb17-9"><a href="#cb17-9" aria-hidden="true"></a>  <span class="cf">return</span> t_double_new (self-&gt;value + value);</span>
<span id="cb17-10"><a href="#cb17-10" aria-hidden="true"></a>}</span></code></pre></div>
<p><code>self</code> is the instance the function belongs to. <code>other</code> is another TDouble instance.</p>
<p>The value of <code>self</code> can be accessed by <code>self-&gt;value</code>, but don’t use <code>other-&gt;value</code> to get the value of <code>other</code>. Use a function <code>t_double_get_value</code> instead. Because <code>self</code> is an instance out of <code>other</code>. Generally, the structure of an object isn’t open to other objects. When an object A access to another object B, A must use a public function provided by B.</p>
<h2 id="exercise">Exercise</h2>
<p>Write functions of TDouble object for subtraction, multiplication, division and sign changing (unary minus). Compare your program to <code>tdouble.c</code> in <a href="../src/tdouble2">src/tdouble2</a> directory.</p>
<p>Up: <a href="index.html">index.html</a>, Prev: <a href="sec2.html">Section 2</a>, Next: <a href="sec4.html">Section 4</a></p>
</body>
</html>
